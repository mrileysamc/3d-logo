
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - cameras - logarithmic depth buffer</title>
		<meta http-equiv="refresh" content="6">
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="./main.css">
		<style>
			body{
				touch-action: none;
			}
			.renderer_label {
				position: absolute;
				bottom: 1em;
				width: 100%;
				color: white;
				z-index: 10;
				display: block;
				text-align: center;
			}

			#container {
				display: flex;
			}

			/* #container_normal {
				width: 0%;
				display: inline-block;
				position: relative; */
			/* } */

			#container_logzbuf {
				width: 100%;
				display: inline-block;
				position: relative;
			}

			#renderer_border {
				position: absolute;
				top: 0;
				left: 25%;
				bottom: 0;
				width: 2px;
				z-index: 10;
				opacity: .8;
				background: #ccc;
				border: 1px inset #ccc;
				cursor: col-resize;
			}
		</style>
	</head>
	<body style="background-color:black;">

		<div id="container">
			<!-- <div id="container_normal"></div> -->
			<div id="container_logzbuf"></div>
			<div id="renderer_border"></div>
		</div>

		<div id="info">
			<p>.</p>
		</div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "./three.module.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import { FontLoader } from './FontLoader.js';
			import { TextGeometry } from './TextGeometry.js';


			// 1 micrometer to 100 billion light years in one scene, with 1 unit = 1 meter?  preposterous!  and yet...
			const NEAR = 1e-6, FAR = 1e27;
			let SCREEN_WIDTH = window.innerWidth;
			let SCREEN_HEIGHT = window.innerHeight;
			let screensplit = 0, screensplit_right = 0;
			const mouse = [ .5, .5 ];
			let zoompos = - 100, minzoomspeed = 0.1;
			let zoomspeed = minzoomspeed;

			let container, border;
			const objects = {};

			// Generate a number of text labels, from 1Âµm in size up to 100,000,000 light years
			// Try to use some descriptive real-world examples of objects at each scale

			const labeldata = [
				{ size: 1, scale: 1.0, label: 'SitusAMC' } 
			];

			init();

			function init() {

				container = document.getElementById( 'container' );

				const loader = new FontLoader();
				loader.load( './helvetiker_regular.typeface.json', function ( font ) {

					const scene = initScene( font );

					// Initialize two copies of the same scene, one with normal z-buffer and one with logarithmic z-buffer
					// objects.normal = initView( scene, 'normal', false );
					objects.logzbuf = initView( scene, 'logzbuf', true );

					animate();

				} );


				// Resize border allows the user to easily compare effects of logarithmic depth buffer over the whole scene
				border = document.getElementById( 'renderer_border' );
				border.addEventListener( 'pointerdown', onBorderPointerDown );

				window.addEventListener( 'mousemove', onMouseMove );
				window.addEventListener( 'resize', onWindowResize );
				window.addEventListener( 'wheel', onMouseWheel );

			}

			function initView( scene, name, logDepthBuf ) {

				const framecontainer = document.getElementById( 'container_' + name );

				const camera = new THREE.PerspectiveCamera( 100, 0, NEAR, FAR );
				scene.add( camera );

				const renderer = new THREE.WebGLRenderer( { antialias: true, logarithmicDepthBuffer: logDepthBuf } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( SCREEN_WIDTH / 2, SCREEN_HEIGHT );
				renderer.domElement.style.position = 'relative';
				renderer.domElement.id = 'renderer_' + name;
				framecontainer.appendChild( renderer.domElement );

				return { container: framecontainer, renderer: renderer, scene: scene, camera: camera };

			}

			function initScene( font ) {

				const scene = new THREE.Scene();

				scene.add( new THREE.AmbientLight( 0x333333 ) );

				const light = new THREE.DirectionalLight( 0xffffff, 2 );
				light.position.set( 200, 200, 100 );
				scene.add( light );

				const materialargs = {
					color: 0x2f3df3,
					specular: 0x222222,
					shininess: 100,
					emissive: 0x111111
				};


				const labelgeo = new TextGeometry( 'SitusAMC', {
					font: font,
					size: 1,
					height: 1 / 2
				} );

				labelgeo.computeBoundingSphere();

				// center text
				labelgeo.translate( - labelgeo.boundingSphere.radius, 0, 0 );

				const material = new THREE.MeshPhongMaterial( materialargs );

				const group = new THREE.Group();
				group.position.z = - 1;
				scene.add( group );

				const textmesh = new THREE.Mesh( labelgeo, material );
				textmesh.scale.set( 1,1,1 );
				textmesh.position.z = - 1;
				textmesh.position.y = 1/4;
				group.add( textmesh );

				return scene;

			}

			function updateRendererSizes() {

				// Recalculate size for both renderers when screen size or split location changes

				SCREEN_WIDTH = window.innerWidth;
				SCREEN_HEIGHT = window.innerHeight;

				screensplit_right = 1 - screensplit;
				// objects.normal.container.style.width = '0%';

				objects.logzbuf.renderer.setSize(  SCREEN_WIDTH, SCREEN_HEIGHT );
				objects.logzbuf.camera.aspect =  SCREEN_WIDTH / SCREEN_HEIGHT;
				objects.logzbuf.camera.updateProjectionMatrix();
				objects.logzbuf.camera.setViewOffset( SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, SCREEN_WIDTH , SCREEN_HEIGHT );
				objects.logzbuf.container.style.width = '100%';

				border.style.left = '0%';

			}

			function animate() {

				requestAnimationFrame( animate );
				render();

			}

			function render() {

				// Put some limits on zooming
				const minzoom = 0.0001;
				const maxzoom = 100000;
				let damping = ( Math.abs( zoomspeed ) > minzoomspeed ? .95 : 1.0 );

				// Zoom out faster the further out you go
				const zoom = THREE.MathUtils.clamp( Math.pow( Math.E, zoompos ), minzoom, maxzoom );
				zoompos = Math.log( zoom );

				// Slow down quickly at the zoom limits
				if ( ( zoom == minzoom && zoomspeed < 0 ) || ( zoom == maxzoom && zoomspeed > 0 ) ) {

					damping = .85;

				}

				zoompos += zoomspeed;
				zoomspeed *= damping;

				objects.logzbuf.camera.position.x = Math.sin( .5 * Math.PI * ( mouse[ 0 ] - .5 ) ) * zoom;
				objects.logzbuf.camera.position.y = Math.sin( .25 * Math.PI * ( mouse[ 1 ] - .5 ) ) * zoom;
				objects.logzbuf.camera.position.z = Math.cos( .5 * Math.PI * ( mouse[ 0 ] - .5 ) ) * zoom;
				objects.logzbuf.camera.lookAt( objects.logzbuf.scene.position );

				// Update renderer sizes if the split has changed
				if ( screensplit_right != 1 - screensplit ) {

					updateRendererSizes();

				}

				objects.logzbuf.renderer.render( objects.logzbuf.scene, objects.logzbuf.camera );

			}

			function onWindowResize() {

				updateRendererSizes();

			}

			function onBorderPointerDown() {

				// activate draggable window resizing bar
				window.addEventListener( 'pointermove', onBorderPointerMove );
				window.addEventListener( 'pointerup', onBorderPointerUp );

			}


			function onBorderPointerUp() {

				window.removeEventListener( 'pointermove', onBorderPointerMove );
				window.removeEventListener( 'pointerup', onBorderPointerUp );

			}

			function onMouseMove( ev ) {

				mouse[ 0 ] = ev.clientX / window.innerWidth;
				mouse[ 1 ] = ev.clientY / window.innerHeight;

			}

			function onMouseWheel( ev ) {

				const amount = ev.deltaY;
				if ( amount === 0 ) return;
				const dir = amount / Math.abs( amount );
				zoomspeed = dir / 10;

				// Slow down default zoom speed after user starts zooming, to give them more control
				minzoomspeed = 0.001;

			}
		</script>
	</body>
</html>
